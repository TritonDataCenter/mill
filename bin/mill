#!/usr/bin/env node
/**
 * Copyright (c) 2013 Joyent Inc. All rights reserved.
 */

var p = console.log;
var crypto = require('crypto');
var fs = require('fs');
var path = require('path');
var util = require('util'),
    format = util.format;

var assert = require('assert-plus');
var async = require('async');
var bunyan = require('bunyan');
var cmdln = require('cmdln'),
    Cmdln = cmdln.Cmdln;
var manta = require('manta');
var sprintf = require('extsprintf').sprintf;

var common = require('../lib/common'),
    zeroPad = common.zeroPad;
var errors = require('../lib/errors');



//---- globals & config

var NAME = 'mill';

var log = bunyan.createLogger({
    name: NAME,
    serializers: bunyan.stdSerializers,
    stream: process.stderr,
    level: 'info'
});



//---- internal support stuff

/**
 * Return a time for the given ISO date or time of day string, if can.
 * Else return undefined.
 */
function parseTime(s, now) {
    var d;
    if (s === 'now') {
        d = now;
    } else if (/^\d{4}-\d{2}-\d{2}/.test(s)) {
        try {
            d = new Date(s);
        } catch(e) {}
    } else if (/^\d{2}:\d{2}(:\d{2}Z?)?$/.test(s)) {
        // Time of day: use that time from today (or yesterday)
        d = new Date(now.toISOString().split('T')[0] + 'T' + s);
        if (d > now) {
            d = new Date(d.valueOf() - 24 * 60 * 60 * 1000);
        }
    }
    if (d && String(d) === 'Invalid Date') {
        d = undefined;
    }
    return d;
}

/**
 * Calculate a relative date.
 */
function relativeDate(relTo, op, range) {
    assert.object(relTo, 'relTo');
    assert.ok(['-', '+'].indexOf(op) !== -1);
    assert.string(range, 'range');

    var rangePat = /^(\d+)([smhd])$/;
    var match = rangePat.exec(range);
    if (!match) {
        throw new Error(format('invalid range: "%s"', range));
    }

    var num = match[1];
    var type = match[2];
    var delta = 0;
    switch (type) {
        case 's':
            delta += num * 1000;
            break;
        case 'm':
            delta += num * 60 * 1000;
            break;
        case 'h':
            delta += num * 60 * 60 * 1000;
            break;
        case 'd':
            delta += num * 24 * 60 * 60 * 1000;
            break;
        default:
            break;
    }

    var t = relTo.valueOf();
    if (op === '+') {
        t += delta;
    } else {
        t -= delta;
    }
    return new Date(t);
}


/**
 * Parsing the 'start' and 'end' args:
 *
 * start=<time> end=<time>
 * start=<time>                 start time - 5m after that
 * start=<time> end=<range>
 * end=<time>                   start 5m before end time - end time
 * start=<range> end=<time>     start <range> time before end - end time
 * start=<range> end=<range>    ???
 *      start=1h end=5m         from an hour ago to 5 minutes after that
 * (no args)                    last 5m range available (10m ago - 5m ago ?)
 */
function parseStartEnd(startArg, endArg) {
    var now = new Date();
    var start = parseTime(startArg, now);
    var end = parseTime(endArg, now);

    if (start && end) {
        /* pass */
    } else if (start) {
        end = relativeDate(start, '+', endArg || '5m');
    } else if (end) {
        start = relativeDate(end, '-', startArg || '5m');
    } else {
        start = relativeDate(now, '-', '10m');
        end = relativeDate(start, '+', '5m');
    }

    if (end < start) {
        throw new Error(format('end "%s" is before start "%s"',
            end.toISOString(), start.toISOString()));
        return;
    }

    return {start: start, end: end};
}



//---- the CLI

function Mill() {
    Cmdln.call(this, {
        name: NAME,
        desc: 'Mill client to search, analyze and report on logs in Manta.',
        options: [
            {names: ['help', 'h'], type: 'bool', help: 'Print help and exit.'},
            {name: 'version', type: 'bool', help: 'Print version and exit.'},
            {names: ['verbose', 'v'], type: 'bool', help: 'Verbose/debug output.'}
        ],
        //helpBody: {
        //
        //},
        helpOpts: {
            includeEnv: true,
            minHelpCol: 23 /* line up with option help */
        }
    });
}
util.inherits(Mill, Cmdln);

// Custom `init` to handle custom options (i.e. 'version' defined above).
Mill.prototype.init = function (opts, args, callback) {
    if (opts.version) {
        p(this.name, VERSION);
        callback(false);
        return;
    }
    this.opts = opts;
    if (opts.verbose) {
        log.level('trace');
        log.src = true;
    }

    var self = this;
    this.configPath = '/var/db/mill/millconfig.json';
    this.__defineGetter__('config', function () {
        if (!self._configCache) {
            self._configCache = common.loadConfigSync(self.configPath);
        }
        return self._configCache;
    });
    this.__defineGetter__('dataDir', function () {
        if (!self._dataDirCache) {
            var config = self.config;
            self._dataDirCache = path.join('/', config.account, 'stor', 'mill');
        }
        return self._dataDirCache;
    });
    this.__defineGetter__('mantaClient', function () {
        var config = self.config;
        return manta.createClient({
            sign: manta.cliSigner({
                keyId: config.keyId,
                user: config.account
            }),
            user: config.account,
            url: config.url,
            log: log
        });
    });

    // Cmdln class handles `opts.help`.
    Cmdln.prototype.init.apply(this, arguments);
};

/**
 * Return a milld Manta path for the given subpath element(s).
 */
Mill.prototype.mpath = function mpath() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
        args.push(String(arguments[i]));
    }
    var tail = path.join.apply(null, args);
    return path.join(this.dataDir, tail);
};


Mill.prototype.do_cat = function (subcmd, opts, args, callback) {
    var self = this;
    if (opts.help) {
        this.do_help('help', {}, [subcmd], callback);
        return;
    }

    var startArg;
    var endArg;
    var svc;
    var inst;
    for (var i = 0; i < args.length; i++) {
        var arg = args[i];
        var eq = arg.indexOf('=');
        if (eq === -1) {
            callback(new errors.UsageError('invalid argument, no "=": ' + arg));
            return;
        }
        var field = arg.slice(0, eq);
        var value = arg.slice(eq + 1);
        switch (field) {
        case 'service':
        case 'svc':
        case 's':
            svc = value;
            break;
        case 'instance':
        case 'inst':
        case 'i':
            inst = value;
            break;
        case 'start':
            startArg = value;
            break;
        case 'end':
            endArg = value;
            break;
        default:
            callback(new errors.UsageError('unknown field: ' + field));
            return;
        }
    }
    if (!svc) {
        callback(new errors.UsageError('no log "service" was given'));
        return;
    }
    if (!inst) {
        callback(new errors.UsageError('no log "instance" was given'));
        return;
    }

    try {
        var dates = parseStartEnd(startArg, endArg);
    } catch (e) {
        callback(new errors.UsageError(e, String(e)));
        return;
    }
    var start = dates.start;
    var end = dates.end;

    log.info('cat service "%s" instance "%s" logs from %s to %s',
        svc, inst, start.toISOString(), end.toISOString());

    var hours = [];
    var currMs = (new Date(         // start of start hour
        start.toISOString().split(':')[0] + ':00:00Z')).valueOf();
    var endMs = end.valueOf() - 1;  // just before 'end'
    while (currMs < endMs) {
        hours.push(new Date(currMs));
        currMs += 60 * 60 * 1000;
    }
    hours = hours.map(function (d) {
        return format('%s/%s/%s/%s', d.getFullYear(),
            zeroPad(d.getUTCMonth() + 1, 2),
            zeroPad(d.getUTCDate(), 2),
            zeroPad(d.getUTCHours(), 2));
    });
    p('XXX need to consider logs for these hours', hours)

    callback();
};
Mill.prototype.do_cat.options = [
    {
        names: ['help', 'h'],
        type: 'bool',
        help: 'Show this help.'
    }
];
Mill.prototype.do_cat.help = (
    'Cat the given time range of a log for a service instance.\n'
    + '\n'
    + 'Usage:\n'
    + '     {{name}} cat service=<service> instance=<instance> \\\n'
    + '         [start=<time>] [end=<time-or-range>]\n'
    + '\n'
    + '{{options}}\n'
    + 'XXX doc\n'
);

Mill.prototype.do_grep = function (subcmd, opts, args, callback) {
    var self = this;
    if (opts.help) {
        this.do_help('help', {}, [subcmd], callback);
        return;
    } else if (args.length !== 0) {
        return callback(new errors.UsageError(sprintf(
            'incorrect number of arguments: "%s"', args.join(' '))));
    }

    XXX
    callback();
};
Mill.prototype.do_grep.options = [
    {
        names: ['help', 'h'],
        type: 'bool',
        help: 'Show this help.'
    }
];
Mill.prototype.do_grep.help = (
    'Grep some logs.\n'
    + '\n'
    + 'Usage:\n'
    + '     {{name}} grep ...\n'
    + '\n'
    + '{{options}}'
);




//---- mainline

if (require.main === module) {
    var mill = new Mill();
    mill.main(process.argv, function (err, subcmd) {
        var code = err && (err.body ? err.body.code : err.code);
        if (err && code !== 'NoCommand') {
            var subcmdStr = subcmd ? ' ' + subcmd : '';
            if (code) {
                console.error('%s%s: error (%s): %s', mill.name, subcmdStr,
                    code, err.message);
            } else {
                console.error('%s%s: error: %s', mill.name, subcmdStr,
                    err.message);
            }
            if (mill.opts.verbose && err.stack) {
                console.error('\n' + err.stack);
            }
            process.exit(err.exitStatus !== undefined ? err.exitStatus : 1);
        } else {
            process.exit(0);
        }
    });
}
// vim: set softtabstop=4 shiftwidth=4:
