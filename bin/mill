#!/usr/bin/env node
/**
 * Copyright (c) 2013 Joyent Inc. All rights reserved.
 */

var p = console.log;
var crypto = require('crypto');
var fs = require('fs');
var path = require('path');
var util = require('util'),
    format = util.format;

var assert = require('assert-plus');
var async = require('async');
var bunyan = require('bunyan');
var cmdln = require('cmdln'),
    Cmdln = cmdln.Cmdln;
var manta = require('manta');
var sprintf = require('extsprintf').sprintf;

var common = require('../lib/common');
var errors = require('../lib/errors');



//---- globals & config

var NAME = 'milld';

var log = bunyan.createLogger({
    name: NAME,
    serializers: bunyan.stdSerializers,
    stream: process.stderr,
    level: 'info'
});



//---- internal support stuff



//---- the CLI

function Mill() {
    Cmdln.call(this, {
        name: NAME,
        desc: 'Mill client to search, analyze and report on logs in Manta.',
        options: [
            {names: ['help', 'h'], type: 'bool', help: 'Print help and exit.'},
            {name: 'version', type: 'bool', help: 'Print version and exit.'},
            {names: ['verbose', 'v'], type: 'bool', help: 'Verbose/debug output.'}
        ],
        //helpBody: {
        //
        //},
        helpOpts: {
            includeEnv: true,
            minHelpCol: 23 /* line up with option help */
        }
    });
}
util.inherits(Mill, Cmdln);

// Custom `init` to handle custom options (i.e. 'version' defined above).
Mill.prototype.init = function (opts, args, callback) {
    if (opts.version) {
        p(this.name, VERSION);
        callback(false);
        return;
    }
    this.opts = opts;
    if (opts.verbose) {
        log.level('trace');
        log.src = true;
    }

    var self = this;
    this.configPath = '/var/db/mill/millconfig.json'; // TODO: /etc ?
    this.__defineGetter__('config', function () {
        if (!self._configCache) {
            self._configCache = self.loadConfig();
        }
        return self._configCache;
    });
    this.__defineGetter__('dataDir', function () {
        if (!self._dataDirCache) {
            var config = self.config;
            self._dataDirCache = path.join('/', config.account, 'stor', 'mill');
        }
        return self._dataDirCache;
    });
    this.__defineGetter__('client', function () {
        //XXX
        return manta.createClient({
            sign: manta.cliSigner({
                keyId: opts.keyId,
                user: opts.account
            }),
            user: opts.account,
            url: opts.url,
            log: log
        });
    });

    // Cmdln class handles `opts.help`.
    Cmdln.prototype.init.apply(this, arguments);
};


Mill.prototype.loadConfig = function loadConfig() {
    return JSON.parse(fs.readFileSync(self.configPath, 'utf8'));
};


Mill.prototype.do_grep = function (subcmd, opts, args, callback) {
    var self = this;
    if (opts.help) {
        this.do_help('help', {}, [subcmd], callback);
        return;
    } else if (args.length !== 0) {
        return callback(new errors.UsageError(sprintf(
            'incorrect number of arguments: "%s"', args.join(' '))));
    }

    XXX
    callback();
};
Mill.prototype.do_grep.options = [
    {
        names: ['help', 'h'],
        type: 'bool',
        help: 'Show this help.'
    }
];
Mill.prototype.do_grep.help = (
    'Grep some logs.\n'
    + '\n'
    + 'Usage:\n'
    + '     {{name}} grep ...\n'
    + '\n'
    + '{{options}}'
);




//---- mainline

if (require.main === module) {
    var mill = new Mill();
    mill.main(process.argv, function (err, subcmd) {
        var code = err && (err.body ? err.body.code : err.code);
        if (err && code !== 'NoCommand') {
            var subcmdStr = subcmd ? ' ' + subcmd : '';
            if (code) {
                console.error('%s%s: error (%s): %s', mill.name, subcmdStr,
                    code, err.message);
            } else {
                console.error('%s%s: error: %s', mill.name, subcmdStr,
                    err.message);
            }
            if (mill.opts.verbose && err.stack) {
                console.error('\n' + err.stack);
            }
            process.exit(err.exitStatus !== undefined ? err.exitStatus : 1);
        } else {
            process.exit(0);
        }
    });
}
